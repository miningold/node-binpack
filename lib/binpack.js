// Generated by CoffeeScript 1.3.3
var Bin, Canvas, Image, Node, Rect, fs, pack, packData, packImage;

fs = require('fs');

Canvas = require('canvas');

Image = Canvas.Image;

exports.version = require('../package').version;

Rect = (function() {

  function Rect(x, y, w, h) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
  }

  Rect.prototype.contains = function(other) {
    return this.w >= other.w && this.h >= other.h;
  };

  Rect.prototype.equals = function(other) {
    return this.w === other.w && this.h === other.h;
  };

  Rect.prototype.toSimple = function() {
    return {
      x: this.x,
      y: this.y,
      w: this.w,
      h: this.h
    };
  };

  return Rect;

})();

Node = (function() {

  function Node() {
    this.left = null;
    this.right = null;
    this.rect = null;
    this.filled = false;
  }

  Node.prototype.insertRect = function(rect) {
    var heightDiff, me, widthDiff;
    if (this.left) {
      return this.left.insertRect(rect) || this.right.insertRect(rect);
    }
    if (this.filled) {
      return null;
    }
    if (!this.rect.contains(rect)) {
      return null;
    }
    if (rect.equals(this.rect)) {
      this.filled = true;
      return this;
    }
    this.left = new Node;
    this.right = new Node;
    widthDiff = this.rect.w - rect.w;
    heightDiff = this.rect.h - rect.h;
    me = this.rect;
    if (widthDiff > heightDiff) {
      this.left.rect = new Rect(me.x, me.y, rect.w, me.h);
      this.right.rect = new Rect(me.x + rect.w, me.y, me.w - rect.w, me.h);
    } else {
      this.left.rect = new Rect(me.x, me.y, me.w, rect.h);
      this.right.rect = new Rect(me.x, me.y + rect.h, me.w, me.h - rect.h);
    }
    return this.left.insertRect(rect);
  };

  return Node;

})();

Bin = {};

pack = function(imageDir, w, h) {
  var canvas, ctx, data, image, images, img, map, node, r, rect, startNode, _i, _len;
  canvas = Bin.canvas = new Canvas(w, h);
  ctx = Bin.ctx = canvas.getContext('2d');
  images = fs.readdirSync(imageDir);
  startNode = new Node;
  startNode.rect = new Rect(0, 0, canvas.width, canvas.height);
  map = {
    images: []
  };
  for (_i = 0, _len = images.length; _i < _len; _i++) {
    image = images[_i];
    data = fs.readFileSync(imageDir + '/' + image);
    img = new Image;
    img.src = data;
    rect = new Rect(0, 0, img.width, img.height);
    node = startNode.insertRect(rect);
    if (node) {
      r = node.rect;
      map.images[image] = r.toSimple();
      ctx.drawImage(img, r.x, r.y);
    } else {
      throw "Not enough room for image: " + image;
    }
  }
  return map;
};

exports.packImage = packImage = function(imageDir, output, w, h) {
  var map, out, stream;
  map = pack(imageDir, w, h);
  out = fs.createWriteStream(output);
  stream = Bin.canvas.createPNGStream();
  stream.on('data', function(chunk) {
    return out.write(chunk);
  });
  return map;
};

exports.packData = packData = function(imageDir, w, h) {
  var map;
  map = pack(imageDir, w, h);
  map.data = Bin.canvas.toDataURL();
  return map;
};
